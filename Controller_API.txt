Auth (à¸£à¸°à¸šà¸šà¸¥à¹‡à¸­à¸à¸­à¸´à¸™)
-user(à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸‡à¸²à¸™)
    - register
    - login

-admin(à¸œà¸¹à¹‰à¸”à¸¹à¹à¸¥)
    - à¸ªà¸£à¹‰à¸²à¸‡ user à¹„à¸”à¹‰
    - à¸£à¸±à¹€à¸‹à¹‡à¸•à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¹ƒà¸«à¹‰ user


Reservation (à¸£à¸°à¸šà¸šà¸ˆà¸­à¸‡)

à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§
Auth
âœ…POST /login -à¸¥à¹‡à¸­à¸à¸­à¸´à¸™
âœ…POST /register -à¸ªà¸¡à¸±à¸„à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™

Admin middleware
âœ…POST /create-user -à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸‡à¸²à¸™
âœ…PATCH /resetpassword-user -à¸£à¸µà¹€à¸‹à¹‡à¸•à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸‡à¸²à¸™
âœ…PATCH /approve/:reservation_id -à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¸à¸²à¸£à¸ˆà¸­à¸‡ à¸ªà¹ˆà¸‡ à¹€à¸¡à¸¥
âœ…PATCH /reject/:reservation_id -à¹„à¸¡à¹ˆà¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¸à¸²à¸£à¸ˆà¸­à¸‡ à¸ªà¹ˆà¸‡ à¹€à¸¡à¸¥
âœ…POST /createroom -à¸ªà¸£à¹‰à¸²à¸‡à¸«à¹‰à¸­à¸‡
âœ…GET /getroomdata/:roomId -à¹€à¸¥à¸·à¸­à¸à¸”à¸¹à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™à¸«à¹‰à¸­à¸‡
âœ…POST /createstatusreservation -à¸ªà¸£à¹‰à¸²à¸‡à¸ªà¸–à¸²à¸™à¸°à¸à¸²à¸£à¸ˆà¸­à¸‡à¸«à¹‰à¸­à¸‡ (1=à¸£à¸­ 2=à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´ 3=à¹„à¸¡à¹ˆà¸­à¸™à¸¸à¸¡à¸±à¸•à¸´)
âœ…GET /allreservation -à¸”à¸¹à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸à¸²à¸£à¸ˆà¸­à¸‡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
âœ…GET /generateadminqrcode -à¹€à¸ˆà¸™ qrcode à¹à¸­à¸”à¸¡à¸´à¸™
Admin Dashbord
âœ…GET /dashbord-status
-à¸„à¸³à¸‚à¸­à¸£à¸­à¸à¸²à¸£à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´(à¸ˆà¸³à¸™à¸§à¸™)
-à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¹à¸¥à¹‰à¸§(à¸ˆà¸³à¸™à¸§à¸™)
-à¸«à¹‰à¸­à¸‡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”(à¸ˆà¸³à¸™à¸§à¸™)
-à¸ˆà¸³à¸™à¸§à¸™ User à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”(à¸ˆà¸³à¸™à¸§à¸™)
-à¸ˆà¸³à¸™à¸§à¸™ Admin à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”(à¸ˆà¸³à¸™à¸§à¸™)
âœ…GET /getroomusagestats -à¸¢à¸­à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¹à¸•à¹ˆà¸¥à¸°à¸«à¹‰à¸­à¸‡à¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡à¸ˆà¸²à¸à¸à¸²à¸£à¹€à¸Šà¹‡à¸„à¸­à¸´à¸™(à¸Ÿà¸´à¸§à¹€à¸•à¸­à¸£à¹Œ à¹à¸¢à¸à¹€à¸”à¸·à¸­à¸™ / à¹à¸¢à¸à¸›à¸µ)
âœ…GET /getuserusagesummary -à¸à¸²à¸£à¸ˆà¸­à¸‡à¹à¸¥à¸°à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸«à¹‰à¸­à¸‡à¸‚à¸­à¸‡ user (à¸Ÿà¸´à¸§à¹€à¸•à¸­à¸£à¹Œ à¹à¸¢à¸à¹€à¸”à¸·à¸­à¸™ / à¹à¸¢à¸à¸›à¸µ / à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰)
âœ…GET /getrecentlogs -Logmini(à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¥à¹Œ)

User 
âœ…POST /createreservation -à¸ˆà¸­à¸‡à¸«à¹‰à¸­à¸‡ à¸ˆà¸­à¸‡à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸ªà¹ˆà¸‡à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™à¹„à¸›à¹ƒà¸™à¸à¸¥à¸¸à¹ˆà¸¡ Telegarm
âœ…GET /getmyreservations -à¹à¸ªà¸”à¸‡à¸£à¸²à¸¢à¸à¸²à¸£à¸à¸²à¸£à¸ˆà¸­à¸‡



à¹€à¸žà¸´à¹ˆà¸¡ API
-à¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸«à¸™à¹‰à¸² Dashbord Admin
 âš ï¸à¸«à¹‰à¸­à¸‡à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸‡à¸²à¸™(à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¥à¹Œ)


-Admin
 âš ï¸à¹à¸à¹‰à¹„à¸‚à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹à¸¥à¸°à¹ƒà¸«à¹‰à¸ªà¸´à¸—à¸˜à¸´à¹Œ User
 âš ï¸à¸ªà¸£à¹‰à¸²à¸‡à¸šà¸±à¸à¸Šà¸µ Admin à¹„à¸”à¹‰à¹€à¸¥à¸¢
 âš ï¸à¹à¸à¹‰à¹„à¸‚à¹à¸¥à¸°à¸¥à¸š Admin à¹„à¸”à¹‰ à¹à¸¥à¸°à¸ªà¸£à¸²à¹‰à¸‡ qrcode à¹„à¸”à¹‰

 

 -User

 


 






















































const http = require("http");
const express = require("express");
const morgan = require("morgan");
const { readdirSync } = require("fs");
const cors = require("cors");
const WebSocket = require("ws");
const os = require("os");
const moment = require("moment");
// const {rooms} = require("./controller/logs_controller");
const pool = require("./config/db");
const PORT = 5000;
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });
let clients = new Map();
require("dotenv").config();

app.use(express.json());
app.use(cors());
app.use(morgan("dev"));

app.get("/", (req, res) => {
  res.send("Hello World");
});

readdirSync("./routes").forEach((file) => {
  app.use("/api", require(`./routes/${file}`));
});

function getLocalIP() {
  const interfaces = os.networkInterfaces();
  for (let interfaceName in interfaces) {
    for (let iface of interfaces[interfaceName]) {
      if (iface.family === "IPv4" && !iface.internal) {
        return iface.address;
      }
    }
  }
  return "Unknown IP";
}

const LOCAL_IP = getLocalIP();
console.log(`ðŸš€ WebSocket Server running on ws://${LOCAL_IP}:${PORT}`);

// âœ… à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸¥à¸·à¸­à¸à¸«à¹‰à¸­à¸‡à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¹„à¸”à¹‰ à¸“ à¸‚à¸“à¸°à¸™à¸µà¹‰
// function getCurrentRoom(roomId) {
//   if (!rooms[roomId] || !Array.isArray(rooms[roomId])) return null;

//   const now = moment();
//   const today = now.format("YYYY-MM-DD");

//   const activeRoom = rooms[roomId].find((room) => {
//     let roomDate = moment(room.date, "YYYY-MM-DD");
//     let startTime = moment(
//       `${room.date} ${room.start_time}`,
//       "YYYY-MM-DD HH:mm"
//     );
//     let endTime = moment(`${room.date} ${room.end_time}`, "YYYY-MM-DD HH:mm");

//     console.log(
//       `ðŸ”Ž Checking Room: ${room.room_id}, Date: ${room.date}, Start: ${room.start_time}, End: ${room.end_time}`
//     );
//     console.log(
//       `ðŸ“† Today: ${today}, Room Date: ${roomDate.format("YYYY-MM-DD")}`
//     );
//     console.log(
//       `ðŸ•’ Current Time: ${now.format("HH:mm")}, Start Time: ${startTime.format(
//         "HH:mm"
//       )}, End Time: ${endTime.format("HH:mm")}`
//     );

//     return (
//       roomDate.isSame(today, "day") && // âœ… à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™à¸‚à¸­à¸‡à¸§à¸±à¸™à¸™à¸µà¹‰
//       now.isSameOrAfter(startTime) && // âœ… à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¹€à¸£à¸´à¹ˆà¸¡à¹à¸¥à¹‰à¸§
//       now.isBefore(endTime) // âœ… à¸•à¹‰à¸­à¸‡à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸«à¸¡à¸”à¹€à¸§à¸¥à¸²
//     );
//   });

//   if (!activeRoom) {
//     // console.log(`â³ No active room for ${roomId}, waiting for start time.`);
//   } else {
//     console.log(
//       `âœ… Active Room Found: ${activeRoom.room_id}, User: ${activeRoom.user_name}`
//     );
//   }

//   return activeRoom || null;
// }

// âœ… à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸«à¹‰à¸­à¸‡à¹ƒà¸«à¹‰ ESP32 (à¹à¸à¹‰à¹„à¸‚à¹ƒà¸«à¹‰à¹€à¸Šà¹‡à¸„à¸§à¸±à¸™)
async function sendRoomData(ws, roomId) {
  const now = moment();
  const currentTime = now.format("HH:mm");
  const currentDate = now.format("YYYY-MM-DD");

  try {
    const [rows] = await pool.query(
      `SELECT r.*, u.username AS username
   FROM reservation r
   JOIN users u ON r.user_id = u.user_id
   WHERE r.room_id = ? 
     AND r.date = ?  
     AND r.status_id = 2
     AND r.sent_to_esp32 = 0
     AND NOT EXISTS (
       SELECT 1 FROM room_logs l
       WHERE l.room_id = r.room_id AND l.user_id = r.user_id 
         AND l.action = 'check_in' AND l.check_in_date = DATE(r.date)
     )
   ORDER BY r.start_time ASC
   LIMIT 1`,
      [roomId, currentDate]
    );

    const activeRoom = rows[0];

    if (activeRoom) {
      const startTime = moment(
        `${activeRoom.date} ${activeRoom.start_time}`,
        "YYYY-MM-DD HH:mm"
      );
      const endTime = moment(
        `${activeRoom.date} ${activeRoom.end_time}`,
        "YYYY-MM-DD HH:mm"
      );

      if (now.isSameOrAfter(startTime) && now.isBefore(endTime)) {
        const roomData = {
          reservation_id: activeRoom.reservation_id,
          user_id: activeRoom.user_id,
          room_id: activeRoom.room_id,
          date: moment(activeRoom.date).format("YYYY-MM-DD"),
          start_time: activeRoom.start_time,
          end_time: activeRoom.end_time,
          unlock_key: activeRoom.unlock_key,
          sent_to_esp32: activeRoom.sent_to_esp32,
          username: activeRoom.username,
        };

        ws.send(JSON.stringify({ type: "room_data", data: roomData }));
        console.log(`ðŸ“¤ Sending Room Data to ${roomId} `);

        await pool.query(
          `UPDATE reservation SET sent_to_esp32 = 1 WHERE reservation_id = ?`,
          [activeRoom.reservation_id]
        );
      } else if (now.isBefore(startTime)) {
        console.log(
          `â³ Not yet time to send data. Current Time: ${currentTime}, Start Time: ${activeRoom.start_time}`
        );
      } else if (now.isSameOrAfter(endTime)) {
        console.log(`â³ The time has already expired for Room ID: ${roomId}`);
      }
    } else {
      console.log(`â³ No active room found for Room ID: ${roomId}`);
    }
  } catch (error) {
    console.error("âŒ Failed to send room data:", error);
  }
}

// âœ… à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡ checkEndTime()
async function checkEndTime() {
  const now = moment();
  console.log(
    "â³ Running checkEndTime() at",
    now.format("YYYY-MM-DD HH:mm:ss")
  );

  try {
    const [startingRooms] = await pool.query(
      `SELECT r.*, u.username
       FROM reservation r
       JOIN users u ON r.user_id = u.user_id
       WHERE r.date = ? AND r.start_time = ? 
         AND r.sent_to_esp32 = 0
         AND NOT EXISTS (
           SELECT 1 FROM room_logs l
           WHERE l.room_id = r.room_id AND l.user_id = r.user_id 
             AND l.action = 'check_in' AND l.check_in_date = r.date
         )`,
      [now.format("YYYY-MM-DD"), now.format("HH:mm")]
    );

    if (startingRooms.length > 0) {
      startingRooms.forEach((room) => {
        const ws = clients.get(room.room_id);

        if (ws && ws.readyState === WebSocket.OPEN) {
          console.log(
            `ðŸ“¤ Sending room data to ESP32 for Room ID: ${room.room_id}`
          );
          // console.log(
          //   "ðŸ“¤ Sending room data to ESP32:",
          //   JSON.stringify(room, null, 2)
          // );

          ws.send(JSON.stringify({ type: "room_data", data: room }));

          pool.query(
            `UPDATE reservation SET sent_to_esp32 = 1 WHERE reservation_id = ?`,
            [room.reservation_id]
          );
        } else {
          console.log(
            `ðŸš« à¹„à¸¡à¹ˆà¸¡à¸µà¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ WebSocket à¸ªà¸³à¸«à¸£à¸±à¸š Room ID: ${room.room_id}`
          );
        }
      });
    }
  } catch (error) {
    console.error("âŒ Error checking room expiration:", error);
  }
}

// âœ… à¸•à¸±à¹‰à¸‡à¹€à¸§à¸¥à¸²à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸—à¸¸à¸ 10 à¸§à¸´à¸™à¸²à¸—à¸µ
setInterval(() => {
  // console.log("ðŸ”„ Running checkEndTime()");
  checkEndTime();
}, 10000);

wss.on("connection", (ws) => {
  console.log("ðŸ”Œ New ESP32 Connected");
  //
  ws.on("message", async (message) => {
    try {
      const data = JSON.parse(message);
      console.log("ðŸ“© Received JSON:", data);

      // âœ… Client à¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡à¸«à¹‰à¸­à¸‡
      if (data.join_room) {
        ws.roomId = data.join_room;
        clients.set(data.join_room, ws);
        console.log(`âœ… Room ${data.join_room} successfully added to clients.`);
        sendRoomData(ws, data.join_room);
      }

      // âœ… à¸šà¸±à¸™à¸—à¸¶à¸ log (à¸—à¸±à¹‰à¸‡ admin à¹à¸¥à¸° user à¹ƒà¸Šà¹‰à¸£à¹ˆà¸§à¸¡)
      if (data.type === "room_log" || data.type === "check_in") {
        const {
          user_id,
          room_id,
          role = "user",
          action = "check_in",
          check_in_date,
          check_in_time,
        } = data;

        let reservationId = null;

        if (role === "user" && action === "check_in") {
          const [rows] = await pool.query(
            `SELECT reservation_id FROM reservation WHERE room_id = ? AND date = ? AND user_id = ? LIMIT 1`,
            [room_id, check_in_date, user_id]
          );

          if (rows.length > 0) {
            reservationId = rows[0].reservation_id;
            console.log(`âœ… Found reservation_id=${reservationId} for logging`);
          } else {
            console.warn("âŒ No matching reservation found for check-in log");
          }
        }

        // âœ… à¸šà¸±à¸™à¸—à¸¶à¸ log à¹€à¸‚à¹‰à¸² room_logs (à¹ƒà¸Šà¹‰à¹„à¸”à¹‰à¸—à¸±à¹‰à¸‡ user à¹à¸¥à¸° admin)
        await pool.query(
          `INSERT INTO room_logs (reservation_id, user_id, room_id, role, action, check_in_date, check_in_time)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [
            reservationId,
            user_id,
            room_id,
            role,
            action,
            check_in_date,
            check_in_time,
          ]
        );

        console.log(
          `âœ… Room log saved: ${role} ${action} by user_id=${user_id}` +
            (reservationId ? ` (reservation_id=${reservationId})` : "")
        );
      }
    } catch (error) {
      console.log("âŒ Error parsing JSON:", error);
    }
  });

  ws.on("close", () => {
    console.log("ðŸ”Œ ESP32 Disconnected");
    clients.forEach((value, key) => {
      if (value === ws) clients.delete(key);
    });
  });
});

// âœ… Start Server
server.listen(PORT, () =>
  console.log(`ðŸš€ Server running on ws://localhost:${PORT}`)
);
